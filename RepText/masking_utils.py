"""
Masking utilities for Arabic RepText.

Provides contour-based masks (instead of rectangular bboxes) and per-line
bbox splitting for multi-line text. Tighter masks reduce hallucinated text
outside the intended text area.
"""

import numpy as np
import cv2
from PIL import Image, ImageDraw, ImageFont
from typing import List, Tuple, Optional


def create_contour_mask(
    glyph_image: np.ndarray,
    padding: int = 3,
    width: int = None,
    height: int = None
) -> np.ndarray:
    """
    Create a mask that tightly follows the actual text contours instead of
    using a rectangular bounding box.

    The mask is generated by:
    1. Converting the glyph image to grayscale and thresholding
    2. Finding contours of the text pixels
    3. Drawing filled contours
    4. Dilating by `padding` pixels to give small breathing room

    Args:
        glyph_image: RGB glyph image (white/colored text on black background)
                     as numpy array [H, W, 3]
        padding: Dilation padding in pixels (default: 3)
        width: Optional width override (uses glyph_image width if None)
        height: Optional height override (uses glyph_image height if None)

    Returns:
        Binary mask as numpy array [H, W] with values 0 or 255
    """
    if width is None:
        width = glyph_image.shape[1]
    if height is None:
        height = glyph_image.shape[0]

    # Convert to grayscale and threshold to get text pixels
    if len(glyph_image.shape) == 3:
        gray = cv2.cvtColor(glyph_image, cv2.COLOR_RGB2GRAY)
    else:
        gray = glyph_image.copy()

    _, binary = cv2.threshold(gray, 10, 255, cv2.THRESH_BINARY)

    # Find contours of text pixels
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Draw filled contours onto mask
    mask = np.zeros((height, width), dtype=np.uint8)
    if contours:
        cv2.drawContours(mask, contours, -1, 255, thickness=cv2.FILLED)

    # Dilate to add padding around the text contours
    if padding > 0:
        kernel = np.ones((padding * 2 + 1, padding * 2 + 1), np.uint8)
        mask = cv2.dilate(mask, kernel, iterations=1)

    return mask


def create_contour_position(
    glyph_image: np.ndarray,
    padding: int = 3,
    width: int = None,
    height: int = None
) -> np.ndarray:
    """
    Create a position map based on text contours instead of full bbox rectangle.
    The position map marks the region where text exists.

    Args:
        glyph_image: RGB glyph image as numpy array [H, W, 3]
        padding: Dilation padding in pixels (default: 3)
        width: Optional width override
        height: Optional height override

    Returns:
        Position map as numpy array [H, W] with values 0 or 255
    """
    # The position map is the same as the contour mask for contour-based approach
    return create_contour_mask(glyph_image, padding=padding, width=width, height=height)


def create_bbox_mask(
    bbox: Tuple[int, int, int, int],
    width: int,
    height: int,
    padding: int = 3
) -> np.ndarray:
    """
    Create a rectangular bbox mask with tight padding.
    Fallback for when contour-based masking is not desired.

    Args:
        bbox: (x1, y1, x2, y2) bounding box
        width: Image width
        height: Image height
        padding: Padding around bbox in pixels (default: 3)

    Returns:
        Binary mask as numpy array [H, W] with values 0 or 255
    """
    mask = np.zeros((height, width), dtype=np.uint8)
    y1 = max(0, bbox[1] - padding)
    y2 = min(height, bbox[3] + padding)
    x1 = max(0, bbox[0] - padding)
    x2 = min(width, bbox[2] + padding)
    mask[y1:y2, x1:x2] = 255
    return mask


def create_per_line_masks(
    text_lines: List[str],
    positions: List[Tuple[int, int]],
    font: ImageFont.FreeTypeFont,
    width: int,
    height: int,
    colors: List[Tuple[int, int, int]] = None,
    mask_mode: str = "contour",
    padding: int = 3
) -> Tuple[List[Image.Image], List[Image.Image], List[Image.Image], np.ndarray]:
    """
    Process multiple lines of text with separate tight masks per line.
    Instead of one big rectangle covering all lines, each line gets its own
    contour-based or bbox mask.

    Args:
        text_lines: List of text strings (already shaped if Arabic)
        positions: List of (x, y) positions for each line
        font: PIL font to use
        width: Image width
        height: Image height
        colors: List of (r, g, b) colors for each line (default: white)
        mask_mode: "contour" for contour-based masks, "bbox" for rectangular
        padding: Mask padding in pixels

    Returns:
        Tuple of:
        - canny_list: List of PIL images (canny edges per line)
        - position_list: List of PIL images (position maps per line)
        - mask_list: List of PIL images (masks per line)
        - glyph_all: Combined glyph numpy array [H, W, 3]
    """
    if colors is None:
        colors = [(255, 255, 255)] * len(text_lines)

    canny_list = []
    position_list = []
    mask_list = []
    glyph_all = np.zeros((height, width, 3), dtype=np.uint8)

    for text, pos, color in zip(text_lines, positions, colors):
        # Render single line glyph
        glyph_img = Image.new("RGB", (width, height), (0, 0, 0))
        draw = ImageDraw.Draw(glyph_img)
        draw.text(pos, text, font=font, fill=color)

        glyph_np = np.array(glyph_img)
        bbox = draw.textbbox(pos, text, font=font)

        # Create mask
        if mask_mode == "contour":
            mask_np = create_contour_mask(glyph_np, padding=padding)
            pos_np = create_contour_position(glyph_np, padding=padding)
        else:
            mask_np = create_bbox_mask(bbox, width, height, padding=padding)
            pos_np = np.zeros((height, width), dtype=np.uint8)
            pos_np[bbox[1]:bbox[3], bbox[0]:bbox[2]] = 255

        # Create canny with dilation
        edges = cv2.Canny(
            cv2.cvtColor(glyph_np, cv2.COLOR_RGB2GRAY),
            50, 100
        )
        kernel = np.ones((3, 3), np.uint8)
        edges = cv2.dilate(edges, kernel, iterations=1)
        canny_rgb = 255 - np.stack([edges, edges, edges], axis=2)

        # Append
        canny_list.append(Image.fromarray(canny_rgb))
        position_list.append(Image.fromarray(pos_np))
        mask_list.append(Image.fromarray(mask_np))
        glyph_all += glyph_np

    return canny_list, position_list, mask_list, glyph_all


def create_mask(
    glyph_image: np.ndarray,
    bbox: Tuple[int, int, int, int],
    width: int,
    height: int,
    mode: str = "contour",
    padding: int = 3
) -> np.ndarray:
    """
    Unified mask creation API.

    Args:
        glyph_image: RGB glyph image as numpy array [H, W, 3]
        bbox: (x1, y1, x2, y2) bounding box (used for bbox mode)
        width: Image width
        height: Image height
        mode: "contour" for contour-based, "bbox" for rectangular
        padding: Mask padding in pixels

    Returns:
        Binary mask as numpy array [H, W] with values 0 or 255
    """
    if mode == "contour":
        return create_contour_mask(glyph_image, padding=padding, width=width, height=height)
    else:
        return create_bbox_mask(bbox, width, height, padding=padding)
